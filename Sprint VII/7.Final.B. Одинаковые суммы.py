# Идентификатор успешной посылки - 53572136

# -- ПРИНЦИП РАБОТЫ --
# Сначала проверяем случай, когда сумма всех элементов - нечетная, а значит, в таком случае,
# нельзя будет разделить массив на две части.
# Для подсчета используем массив из булевых значений (dp), ответ после пересчета будет находиться в последней ячейке массива.
# Подсчет ведем от половины суммы всех чисел во входном массиве до значения текущего элемента массива.
# При пересчете считаем, что dp[j] будет равен True, если существует подмножество с суммой равной j, иначе dp[j] будет равен False.
#
# -- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
# Подсчет выполняется в sum_of_arr // 2, т.к., если мы найдем подмножетсво, которое составляет половину суммы всех чисел в множестве,
# то оставшиеся числа в изначальном множетсве тоже будут составлять sum_of_arr // 2, и, соответственно, исходное множество
# можно будет поделить на два этих подмножества.
#
# -- ВРЕМЕННАЯ СЛОЖНОСТЬ --
# Сложность в худшем случае равна O(sum_of_arr * n), где sum_of_arr - сумма всех очков.
#
# -- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
# Сложность в худшем случае равна O(sum_of_arr), где sum_of_arr - сумма всех очков.

import sys


def main():
    n = int(input())
    line = sys.stdin.readline().rstrip()
    points = list(map(int, line.split()))

    sum_of_arr = sum(points)
    if sum_of_arr % 2 != 0:
        print(False)
        return

    half = sum_of_arr // 2
    dp = [False] * (half+1)

    for i in range(n):
        for j in range(half, points[i] - 1, -1):
            if dp[j - points[i]] is True or j == points[i]:
                dp[j] = True

    print(dp[half])


if __name__ == '__main__':
    main()
